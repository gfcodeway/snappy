/**
 * Snappy minimal power server
 * 
 * This is a minimal server that serves static files from the dist files generated by the SPA build process.
 * It is built using Actix-web, a powerful, pragmatic, and extremely fast web framework for Rust.
 * 
 * The server serves the index.html file for all non-file paths, and serves static files with the appropriate content type.
 * It also caches static files for 1 hour.
 * 
 * - To run the server, use the command `cargo run`.
 * - To build the server for production, use the command `cargo build --release`.
 * - To run the server in production, use the command `./target/release/snappy`.  
 *
 * Writed by: @gfcodeway <g.failla@codeway.ch>
 */

use actix_files::NamedFile;
use actix_web::{web, App, HttpServer, HttpRequest, HttpResponse, Result, middleware::Logger, http::header};
use env_logger::Env;
use std::path::PathBuf;
use log::info;

async fn serve_file(req: HttpRequest) -> Result<HttpResponse> {
    let path: PathBuf = req.match_info().query("filename").parse().unwrap();
    let file_path = PathBuf::from("./dist").join(path);

    if file_path.is_file() {
        info!("Serving file: {:?}", file_path);
        let is_js = file_path.extension().and_then(|ext| ext.to_str()) == Some("js");
        let is_css = file_path.extension().and_then(|ext| ext.to_str()) == Some("css");
        
        let named_file = NamedFile::open(&file_path)?;
        let mut response = named_file.into_response(&req);
        
        // Cache static files for 1 hour
        if is_js || is_css{
            response.headers_mut().insert(
                header::CACHE_CONTROL,
                header::HeaderValue::from_static("public, max-age=3600"),
            );
        }

        // Set content type for js and css files 
        Ok(response)
    } else {
        // Serve index.html for all non-file paths
        info!("File not found, serving index: {:?}", file_path);
        Ok(NamedFile::open("./dist/app/index.html")?.into_response(&req))
    }
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // Initialize logger
    env_logger::init_from_env(Env::new().default_filter_or("info"));

    // Start server
    info!("Welcome to Snappy minimal power server!");
    info!("Starting server...");
    info!("Listening on http://127.0.0.1:8080");

    HttpServer::new(|| {
        App::new()
            .wrap(Logger::default())
            .service(web::resource("/{filename:.*}").route(web::get().to(serve_file)))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}

#[cfg(test)]
mod tests {
    use super::*;
    use actix_web::{test, App};
    use std::fs;

    #[actix_rt::test]
    async fn test_serve_existing_file() {
        let mut app = test::init_service(
            App::new().service(web::resource("/{filename:.*}").route(web::get().to(serve_file)))
        ).await;

        // Create a test file
        fs::write("./dist/test.txt", "Hello, world!").unwrap();

        let req = test::TestRequest::get().uri("/test.txt").to_request();
        let resp = test::call_service(&mut app, req).await;

        assert!(resp.status().is_success());

        // Pulire
        fs::remove_file("./dist/test.txt").unwrap();
    }

    #[actix_rt::test]
    async fn test_serve_nonexistent_file() {
        let mut app = test::init_service(
            App::new().service(web::resource("/{filename:.*}").route(web::get().to(serve_file)))
        ).await;

        let req = test::TestRequest::get().uri("/nonexistent.txt").to_request();
        let resp = test::call_service(&mut app, req).await;

        assert!(resp.status().is_success()); // Serve index.html
    }

    #[actix_rt::test]
    async fn test_serve_js_file() {
        let mut app = test::init_service(
            App::new().service(web::resource("/{filename:.*}").route(web::get().to(serve_file)))
        ).await;

        // Create a test JS file
        fs::write("./dist/test.js", "console.log('Hello');").unwrap();

        let req = test::TestRequest::get().uri("/test.js").to_request();
        let resp = test::call_service(&mut app, req).await;

        assert!(resp.status().is_success());
        let headers = resp.headers();
        assert_eq!(headers.get(header::CACHE_CONTROL).unwrap(), "public, max-age=3600");

        // Clean up
        fs::remove_file("./dist/test.js").unwrap();
    }

    #[actix_rt::test]
    async fn test_serve_css_file() {
        let mut app = test::init_service(
            App::new().service(web::resource("/{filename:.*}").route(web::get().to(serve_file)))
        ).await;

        // Create a test CSS file
        fs::write("./dist/test.css", "body { color: black; }").unwrap();

        let req = test::TestRequest::get().uri("/test.css").to_request();
        let resp = test::call_service(&mut app, req).await;

        assert!(resp.status().is_success());
        let headers = resp.headers();
        assert_eq!(headers.get(header::CACHE_CONTROL).unwrap(), "public, max-age=3600");

        // Clean up
        fs::remove_file("./dist/test.css").unwrap();
    }
}